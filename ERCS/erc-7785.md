---
eip: 7785
title: Onchain registration of chain identifiers
description: Derive chain identifiers by hashing the chain name and auxiliary metadata, and use ENS to map names to those identifier
author: Marco Stronati (@paracetamolo), Jeff Lau (@jefflau), Martin Ndeto (@ndeto)
discussions-to: https://ethereum-magicians.org/t/on-chain-registration-of-chain-identifiers/21299
status: Draft
type: Standards Track
category: ERC
created: 2024-09-26
requires: 2304
---

## Abstract

This ERC proposes to derive chain identifiers, (chain_id) as a digest of their chain name (and other information) and to use ENS to map chain names to identifiers in place of the centralized list on GitHub.
A solution to support existing chain identifiers that were not derived following this ERC is also proposed.

## Motivation

The mapping between chain names and identifiers, such as `Mainnet -> 0x1`, is currently maintained in a centralized list.
However this solution has two main shortcomings:

- It does not scale with the growing number of L2s.
- The list maintainers are a single point of failure.

Desired properties:

- the ability to register new chain names and identifiers in a censorship-resistant way
- the ability to resolve chain names and identifiers in a trustless way
- maintain a unique mapping between names and identifiers

### Chain Identifier Spoofing and Replay Attacks

An important property of the centralized list is that it keeps a one-to-one correspondence between names and identifiers.

Without this property, an attacker could register a fresh name pointing to an existing identifier. For example `my-testnet` could point to mainnet `0x1`. A user could be tricked into signing a transaction for the innocent looking `my-testnet` while actually signing a transaction for mainnet, a transaction that the attacker can then replay.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Extending chain identifiers

Current chain identifiers are usually chosen arbitrarily to be short. While these identifiers are convenient on a small scale, as their number increases it is more desirable to draw them from a larger space.

We propose to extend the size of identifiers to 32 bytes and to derive them using a cryptographic hash function.
The input to the function MUST contain the chain name and MAY contain additional information.

An example for a L2:

```solidity
bytes32 chain_id = keccak256(abi.encode(CHAIN_NAME, SETTLEMENT_CHAIN_ID, VERSION, ROLLUP_CONTRACT, CHAIN_TYPE, CHAIN_REFERENCE))
```

where:

- `SETTLEMENT_CHAIN_ID` is the id of the L1 where the L2 settles, it could be Mainnet or a testnet.
- `VERSION` is to separate the domain of the hash function with an arbitrary string
- `ROLLUP_CONTRACT` is the address of the L2 on the L1. Defaults to zero address (0x) for chains that don't have a settlement layer.
- `CHAIN_TYPE` is the [CAIP-350](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-350.md) two-byte identifier representing the type of chain (e.g., '0x0000' for EVM chains).
- `CHAIN_REFERENCE` is the [CAIP-2](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md) chain reference, it is typically the chain ID as defined in the namespace (e.g., '1' for Ethereum Mainnet).

### CoinType Requirements

The coinType field MUST be provided during chain registration and MUST be exposed by the registry interface for address resolution and cross-chain compatibility.

**Example Usage:**

```solidity
address subRegistry = chainRegistry.resolveChainMetadataRegistry(chainId);
uint32 coinType = ChainMetadataRegistry(subRegistry).coinType();
```

### Chain name resolution

Any ENS name **MAY resolve to a chain identifier per [ERC-2304](./eip-2304.md). The resolver **MUST\*\* return the full chain identifier plus all metadata required for verification.

#### cid.eth Suffix

The `cid.eth` ENS namespace is reserved for chain registry usage as defined by this standard.

For example the chain name `rollup` can be converted to a chain identifier on Mainnet by adding the `cid.eth` suffix and resolving as follows:

```
rollup.cid.eth -> chain_id
```

The resolved `chain_id` points to a subregistry managed by the DAO:

```solidity
address ensRootChainRegistry.resolveSubRegistry(chain_id)
string metadata = chainSubRegistry.metadata()
// returns {settlement_chain_id: uint, version : uint, rollup_contract : address, chain_type : uint, chain_reference: string, chain_id: string}
```

and then verified using:

```
chain_id = hash("rollup", settlement_chain_id, version, rollup_contract, chain_type, chain_reference)
```

## Rationale

### CAIP-2 and CAIP-350 Integration in ERC-7785 Chain Identifier

This specification directly incorporates CAIP-350 namespaces and CAIP-2 chain references into the ERC-7785 chain identifier format, to enforce standardization and enhance interoperability.

CAIP-2 defines blockchain networks using a standard format: `namespace:reference`. The namespace identifies the type of chain (e.g., "eip155" for EVM-based chains), and the reference corresponds to a specific chain within the namespace (such as the chain ID).

CAIP-350 specifies a two-byte code that encodes the CAIP-2 namespace. For EVM chains, the CAIP-2 reference is the chain ID itself. Using both standards in ERC-7785 guarantees that chain identifiers are uniquely defined and compatible with existing CAIP formats.

#### ERC-7930 Address and Chain Registry

The format for an ERC-7930 address is:

```
┌─────────┬───────────┬──────────────────────┬────────────────┬───────────────┬─────────┐
│ Version │ ChainType │ ChainReferenceLength │ ChainReference │ AddressLength │ Address │
└─────────┴───────────┴──────────────────────┴────────────────┴───────────────┴─────────┘
```

- `ChainType` represents the CAIP-2 namespace as specified by CAIP-350.
- Within the Ethereum Virtual Machine (EVM) context, the `ChainReference` is the numeric chain ID.

#### Hashing and Registry Resolution

To obtain the 32-byte hash required for resolution in the ERC-7785 registry, hash the attributes of the CAIP-2 chain identifier. In this process, the `chainType` is obtained as a two-byte value (per CAIP-350). This two-byte value is resolved to its CAIP-2 namespace equivalent, a string such as `eip155`. The namespace string and the chain reference are concatenated and hashed together. This hash is then used by ENS resolvers to retrieve the relevant chain details.

The following pseudocode demonstrates how to resolve the chain registry from an ERC-7930 address:

```solidity
// Pseudocode: Resolving chain registry from an ERC-7930 address
string namespace = resolveCaip2Namespace(chainType); // e.g., 0x0000 → "eip155"
string caip2Id = string(abi.encodePacked(namespace, ":", chainReference));
bytes32 caip2Hash = keccak256(bytes(caip2Id));

// Build ENS node for chain registry
bytes32 parentNode = namehash("cid.eth");
bytes32 node = keccak256(abi.encodePacked(parentNode, caip2Hash));

// Resolve chain registry
bytes32 chain_id = ensRootRegistry.resolveCaip2(node); // returns chain_id
```

This approach standardizes the mapping process, ensuring compatibility between CAIP-2 standards, ERC-7930 address formats, and the ERC-7785 registry.

## Backwards Compatibility

Existing identifiers, that were not derived using the scheme above, can be supported using a reverse mapping from chain identifiers to chain names, so that one can check for uniqueness.

For example the chain name `legacy-rollup.cid.eth` can be resolved to the chain identifier `0x123`.
Then `0x123` can be resolved in the `cid.eth` domain to a `chain_name`. This happens in the chain registry
If `chain_name == legacy-rollup` then the mapping is valid.

```solidity
bytes32 chain_id = 0x123
bytes32 parentNode = namehash("cid.eth");
bytes32 node = keccak256(abi.encodePacked(parentNode, chain_id));

// Resolve chain details
string memory chain_name = ensRootRegistry.resolveName(node);
// -> legacy-rollup
```

### Bootstrapping and handover

To bootstrap legacy chain support under the on-chain registry:

- ENS reserves the `cid.eth` namespace and seeds it with known legacy identifiers.
- Rollup teams submit ENS proposals to register their `rollup.eth` names, supplying the full `ChainData` struct as text records:

  ```solidity
  struct ChainData {
      string  chainName;
      uint256 settlementChainId;
      string  version;
      address deployerContract;
      string  chainNamespace;
      string  chainReference;
      uint32  coinType;
  }
  ```

- ENS DAO retains ownership of the Root Registry, while each approved rollup multisig gains control of its SubRegistry for routine updates.
- Any change to the `ChainData` fields used in deriving the `chain_id` must be approved through ENS DAO governance before being applied.

## Security Considerations

Domain spoofing can lead to replay attacks as described above and can be eliminated by deriving new identifiers using a hash function and by checking the reverse mapping for legacy identifiers.

Domain squatting, the practice of ammassing a large number of domains in the hope to selling them later to legitimate users, is a possibility but with an increasing number of L2 registrations we can expect the same problem to appear in the centralized Github list.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
